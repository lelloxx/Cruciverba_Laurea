<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Cruciverba di Laurea</title>
<style>
  :root{ --cell: min(10vw, 44px); }
  body{font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; margin:16px; line-height:1.35}
  h1{margin:8px 0 16px}
  .wrap{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  @media (max-width:900px){ .wrap{grid-template-columns:1fr} }
  table{border-collapse:collapse;border:1px solid #111;background:#111;user-select:none;touch-action:manipulation}
  td{width:var(--cell);height:var(--cell);border:1px solid #333;position:relative;text-align:center;background:#111}
  td.white{background:#fff}
  td input{
    width:100%;height:100%;border:0;outline:none;background:transparent;
    text-transform:uppercase;font-weight:700;font-size:calc(var(--cell)*0.46);text-align:center;
  }
  td .num{position:absolute;top:2px;left:3px;font-size:10px;color:#666}
  .panel{border:1px solid #eee;padding:12px;border-radius:12px}
  .panel h2{margin:6px 0}
  .panel ol{margin:0;padding:0;list-style:none}
  .panel li{margin:6px 0;cursor:pointer}
  .controls{display:flex;gap:8px;align-items:center;margin:10px 0 0}
  button{padding:10px 14px;border:1px solid #333;background:#fff;border-radius:10px;cursor:pointer}
  #status{font-size:14px}
  .ok{padding:12px;border:1px solid #0a0;color:#0a0;border-radius:10px;margin-top:10px;display:none}
  .reveal{display:none;margin-top:10px;padding:12px;border:1px dashed #555;border-radius:10px}
  .correct{background:#e8fbe8 !important}
  .wrong{background:#ffeaea !important}
  .tag{display:inline-block;padding:2px 8px;border:1px solid #999;border-radius:999px;font-size:12px;margin-left:8px}
</style>
</head>
<body>
<h1>Cruciverba di Laurea <span class="tag" id="dirTag">orizzontale</span></h1>

<div class="wrap">
  <div>
    <table id="grid" aria-label="Griglia cruciverba"></table>
    <div class="controls">
      <button id="check">Verifica</button>
      <span id="status" aria-live="polite"></span>
    </div>
    <div id="ok" class="ok">Perfetto! Cruciverba completato ðŸŽ‰</div>
    <div id="reveal" class="reveal">
      <p>Complimenti! Ora puoi inserire lâ€™IBAN qui:</p>
      <p><a href="https://forms.gle/TUO_FORM" target="_blank" rel="noopener">Apri il modulo</a></p>
    </div>
    <p style="font-size:12px;color:#666;margin-top:10px">
      Suggerimento: clicca una <b>cella numerata</b> per impostare automaticamente la direzione
      (orizzontale/verticale). Oppure usa <b>barra spaziatrice</b> o le <b>frecce</b>.
    </p>
  </div>

  <div class="panel">
    <h2>Orizzontali</h2>
    <ol id="across"></ol>
    <h2>Verticali</h2>
    <ol id="down"></ol>
  </div>
</div>

<script>
/* ======= LAYOUT 1:1 (come nel tuo mock) =======
   Across: 1 MICHELE, 4 SOFIA, 7 ITALIANO, 8 ANDREA
   Down:   2 CHIARA, 3 OSLO, 5 EDOARDO, 6 BARONE
   Nota: per rispettare incastri/verticali, CHIARA parte dalla C di MICHELE,
   OSLO Ã¨ verticale e collegato a SOFIA; EDOARDO e BARONE scendono dal top.
*/
const PUZZLE = {
  rows: 11, cols: 11,
  grid: [
    "#MICHELEE##", // r0: 1-MICHELE + E (inizio 5-EDOARDO)
    "O##H####DB#", // r1: 3-OSLO(O), 2-CHIARA(H), 5-EDOARDO(D), 6-BARONE(B)
    "SOFIA###OA#",// r2: 4-SOFIA, incroci con 3 e 5 e 6
    "L##A####AR#",// r3
    "O##R####RO#",// r4
    "###A####DN#",// r5
    "#ITALIANOE#",// r6: 7-ITALIANO, incrocia 6 (E) e 5 (O)
    "###########",// r7
    "##ANDREA###",// r8: 8-ANDREA
    "###########",// r9
    "###########" // r10
  ],
  across: [
    { num:1, row:0, col:1, answer:"MICHELE", clue:"Si usa per indicare una media alta (7)"},
    { num:4, row:2, col:0, answer:"SOFIA", clue:"Organizzatrice di eventi (5)"},
    { num:7, row:6, col:1, answer:"ITALIANO", clue:"Ci ha insegnato a distinguere cani e gatti (8)"},
    { num:8, row:8, col:2, answer:"ANDREA", clue:"Panino speciale e pizza bianca (6)"}
  ],
  down: [
    { num:2, row:0, col:3, answer:"CHIARA", clue:"Anche se urla non si sente (6)"},
    { num:3, row:1, col:0, answer:"OSLO", clue:"La meta Erasmus preferita delle Luissine (4)"},
    { num:5, row:0, col:8, answer:"EDOARDO", clue:"Sinonimo di massa (7)"},
    { num:6, row:1, col:9, answer:"BARONE", clue:"Dove mangiarsi un bel piatto di pasta (6)"}
  ],
  finalLink: "https://forms.gle/TUO_FORM"
};

/* ======= RENDER ======= */
const gridEl = document.getElementById('grid');
const acrossEl = document.getElementById('across');
const downEl   = document.getElementById('down');
let currentDir = 'across';
const dirTag = document.getElementById('dirTag');
const startDirMap = new Map(); // "r,c" -> {across:true?, down:true?}

function setDir(d){ currentDir = d; dirTag.textContent = d==='across' ? 'orizzontale' : 'verticale'; }
function isWhite(r,c){ const ch = (PUZZLE.grid[r]||"")[c]; return ch && ch !== '#'; }

function renderGrid(){
  gridEl.innerHTML = '';
  for(let r=0;r<PUZZLE.rows;r++){
    const tr = document.createElement('tr');
    for(let c=0;c<PUZZLE.cols;c++){
      const ch = (PUZZLE.grid[r]||"")[c] || '#';
      const td = document.createElement('td');
      if(ch !== '#'){
        td.className = 'white';
        const inp = document.createElement('input');
        inp.maxLength = 1;
        inp.dataset.row = r; inp.dataset.col = c;
        td.appendChild(inp);
      }
      tr.appendChild(td);
    }
    gridEl.appendChild(tr);
  }
  // numerini e mappa start->direzione
  const starts = new Map();
  startDirMap.clear();
  const addStart = (row,col,num,dir)=>{
    const key=`${row},${col}`;
    starts.set(key,num);
    const obj = startDirMap.get(key)||{};
    obj[dir]=true;
    startDirMap.set(key,obj);
  };
  PUZZLE.across.forEach(a=>addStart(a.row,a.col,a.num,'across'));
  PUZZLE.down.forEach(d=>addStart(d.row,d.col,d.num,'down'));

  gridEl.querySelectorAll('td').forEach(td=>{
    const inp = td.querySelector('input');
    if(!inp) return;
    const key = `${+inp.dataset.row},${+inp.dataset.col}`;
    if(starts.has(key)){
      const num = document.createElement('div'); num.className='num'; num.textContent = starts.get(key);
      td.appendChild(num);
      td.addEventListener('click', ()=>{
        const dirs = startDirMap.get(key)||{};
        if(dirs.across && !dirs.down) setDir('across');
        else if(dirs.down && !dirs.across) setDir('down');
      });
    }
  });
}

function renderClues(){
  const make = (arr, el, dir)=> {
    el.innerHTML = '';
    arr.forEach(k=>{
      const li = document.createElement('li');
      li.textContent = `${k.num}. ${k.clue}`;
      li.addEventListener('click', ()=>focusWord(k,dir));
      el.appendChild(li);
    });
  };
  make(PUZZLE.across, acrossEl, 'across');
  make(PUZZLE.down, downEl, 'down');
}

renderGrid(); renderClues();

/* ======= NAVIGAZIONE & INPUT ======= */
function getInput(r,c){ return gridEl.querySelector(`input[data-row="${r}"][data-col="${c}"]`); }

function nextCell(r,c,dir,step=1){
  if(dir==='across'){
    let nc = c + step;
    while(nc>=0 && nc<PUZZLE.cols){ if(isWhite(r,nc)) return [r,nc]; nc += step; }
  }else{
    let nr = r + step;
    while(nr>=0 && nr<PUZZLE.rows){ if(isWhite(nr,c)) return [nr,c]; nr += step; }
  }
  return null;
}
function focusWord(entry, dir){
  setDir(dir);
  const start = getInput(entry.row, entry.col);
  if(start) start.focus();
}

gridEl.addEventListener('keydown', (e)=>{
  const t = e.target; if(!(t instanceof HTMLInputElement)) return;
  const r = +t.dataset.row, c = +t.dataset.col;
  if(e.key===' '){ e.preventDefault(); setDir(currentDir==='across'?'down':'across'); return; }
  if(e.key==='ArrowRight'){ setDir('across'); const n=nextCell(r,c,'across',+1); if(n) getInput(...n).focus(); }
  if(e.key==='ArrowLeft'){  setDir('across'); const n=nextCell(r,c,'across',-1); if(n) getInput(...n).focus(); }
  if(e.key==='ArrowDown'){  setDir('down');   const n=nextCell(r,c,'down',+1);   if(n) getInput(...n).focus(); }
  if(e.key==='ArrowUp'){    setDir('down');   const n=nextCell(r,c,'down',-1);   if(n) getInput(...n).focus(); }
});
gridEl.addEventListener('focusin', (e)=>{
  const t = e.target; if(!(t instanceof HTMLInputElement)) return;
  const key = `${t.dataset.row},${t.dataset.col}`;
  const dirs = startDirMap.get(key)||{};
  if(dirs.across && !dirs.down) setDir('across');
  if(dirs.down && !dirs.across) setDir('down');
});
gridEl.addEventListener('input', (e)=>{
  const t = e.target; if(!(t instanceof HTMLInputElement)) return;
  t.value = t.value.replace(/[^A-Za-zÃ€-Ã–Ã˜-Ã¶Ã¸-Ã¿]/g,'').toUpperCase().slice(0,1);
  if(!t.value) return;
  const r = +t.dataset.row, c = +t.dataset.col;
  const n = nextCell(r,c,currentDir,+1); if(n) getInput(...n).focus();
});

/* ======= VERIFICA ======= */
const statusEl = document.getElementById('status');
const okEl = document.getElementById('ok');
const revealEl = document.getElementById('reveal');

function checkEntry(entry, dir){
  const {row,col,answer} = entry;
  let allCorrect = true;
  for(let i=0;i<answer.length;i++){
    const rr = row + (dir==='down'?i:0);
    const cc = col + (dir==='across'?i:0);
    const cell = getInput(rr,cc); const should = answer[i].toUpperCase();
    const got = (cell?.value || '').toUpperCase(); const td = cell?.closest('td');
    if(!cell||!td) continue;
    td.classList.remove('correct','wrong');
    if(got===should) td.classList.add('correct'); else { allCorrect=false; td.classList.add('wrong'); }
  }
  if(!allCorrect){
    setTimeout(()=>{
      for(let i=0;i<answer.length;i++){
        const rr=row+(dir==='down'?i:0), cc=col+(dir==='across'?i:0);
        const cell=getInput(rr,cc); const td=cell?.closest('td');
        if(td && td.classList.contains('wrong')){ cell.value=''; td.classList.remove('wrong','correct'); }
      }
    }, 900);
  }
  return allCorrect;
}
function allSolved(){
  for(let r=0;r<PUZZLE.rows;r++){
    for(let c=0;c<PUZZLE.cols;c++){
      const sol=(PUZZLE.grid[r]||"")[c]; if(!sol||sol==='#') continue;
      const inp=getInput(r,c); if(!inp || (inp.value.toUpperCase()!==sol.toUpperCase())) return false;
    }
  }
  return true;
}
document.getElementById('check').addEventListener('click', ()=>{
  PUZZLE.across.forEach(a=>checkEntry(a,'across'));
  PUZZLE.down.forEach(d=>checkEntry(d,'down'));
  const solved = allSolved();
  statusEl.textContent = solved ? "Tutto corretto!" : "Ci sono errori, ricontrolla ðŸ˜‰";
  okEl.style.display = solved ? 'block' : 'none';
  revealEl.style.display = solved ? 'block' : 'none';
  if(solved){ revealEl.scrollIntoView({behavior:'smooth', block:'start'}); }
});
</script>
</body>
</html>
